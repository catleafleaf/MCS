#version 430

precision OVERWRITE_PRECISION float;
precision highp int;

#define PI2 6.2831853

layout(local_size_x = RESET_VALUE, local_size_y = 8, local_size_z = 1) in;

struct ComplexArray {
    vec2 red;
    vec2 green;
    vec2 blue;
    vec2 alpha;
};

subroutine vec4 formatPickerLoad(in ivec2 coord);
subroutine uniform formatPickerLoad formatPickerLoadState;
subroutine void formatPickerStore(in ivec2 coord, in ComplexArray result, in bool isGenRGBA);
subroutine uniform formatPickerStore formatPickerStoreState;

layout(binding = 0, rgba8) uniform readonly image2D texIn;
layout(binding = 1, rgba8) uniform writeonly image2D texOut;
layout(binding = 2, rgba16f) uniform readonly image2D texIn16;
layout(binding = 3, rgba16f) uniform writeonly image2D texOut16;
layout(binding = 4, rgba32f) uniform readonly image2D texIn32;
layout(binding = 5, rgba32f) uniform writeonly image2D texOut32;

uniform ivec2 size;
uniform int state; // 0b1 = inverse, 0b10 = vertical, 0b100 = genFromRGBA, 0b1000 = genRGBA;
uniform vec2 sizeDiv;

vec2 getEuler(in float theta) {
    return vec2(cos(theta), sin(theta));
}

vec2 cmul(in vec2 left, in vec2 right)
{
    return vec2(left.x * right.x - left.y * right.y, left.x * right.y + left.y * right.x);
}

subroutine(formatPickerLoad) vec4 bit8Load(in ivec2 coord) {
    return imageLoad(texIn, coord);
}

subroutine(formatPickerLoad) vec4 bit16Load(in ivec2 coord) {
    return imageLoad(texIn16, coord);
}

subroutine(formatPickerLoad) vec4 bit32Load(in ivec2 coord) {
    return imageLoad(texIn32, coord);
}

subroutine(formatPickerStore) void bit8Store(in ivec2 coord, in ComplexArray result, in bool isGenRGBA) {
    vec4 resultStore = isGenRGBA ? vec4(length(result.red), length(result.green), length(result.blue), length(result.alpha)) : vec4(result.red, result.green);
    imageStore(texOut, coord, resultStore);
    if (!isGenRGBA) imageStore(texOut, ivec2(coord.x + size.x, coord.y), vec4(result.blue, result.alpha));
}

subroutine(formatPickerStore) void bit16Store(in ivec2 coord, in ComplexArray result, in bool isGenRGBA) {
    vec4 resultStore = isGenRGBA ? vec4(length(result.red), length(result.green), length(result.blue), length(result.alpha)) : vec4(result.red, result.green);
    imageStore(texOut16, coord, resultStore);
    if (!isGenRGBA) imageStore(texOut16, ivec2(coord.x + size.x, coord.y), vec4(result.blue, result.alpha));
}

subroutine(formatPickerStore) void bit32Store(in ivec2 coord, in ComplexArray result, in bool isGenRGBA) {
    vec4 resultStore = isGenRGBA ? vec4(length(result.red), length(result.green), length(result.blue), length(result.alpha)) : vec4(result.red, result.green);
    imageStore(texOut32, coord, resultStore);
    if (!isGenRGBA) imageStore(texOut32, ivec2(coord.x + size.x, coord.y), vec4(result.blue, result.alpha));
}

ComplexArray transformHFromRGBA(in ivec2 coord, in float centerCoord) {
    float theta, coordF = PI2 * centerCoord * sizeDiv.x;
    vec2 euler;
    vec4 raw;
    ComplexArray result = ComplexArray(vec2(0.0), vec2(0.0), vec2(0.0), vec2(0.0));
    for (int n = 0; n < size.x; ++n) {
        theta = float(n) * coordF;
        euler = getEuler(theta);
        raw = formatPickerLoadState(ivec2(n, coord.y));
        result.red += cmul(vec2(raw.x, 0.0), euler);
        result.green += cmul(vec2(raw.y, 0.0), euler);
        result.blue += cmul(vec2(raw.z, 0.0), euler);
        result.alpha += cmul(vec2(raw.w, 0.0), euler);
    }
    return result;
}

ComplexArray transformH(in ivec2 coord, in float pi, in float centerCoord) {
    float theta, coordF = pi * centerCoord * sizeDiv.x;
    int coordSub = size.x;
    vec2 euler;
    vec4 comp;
    ComplexArray result = ComplexArray(vec2(0.0), vec2(0.0), vec2(0.0), vec2(0.0));
    for (int n = 0; n < size.x; ++n) {
        theta = float(n) * coordF;
        euler = getEuler(theta);
        comp = formatPickerLoadState(ivec2(n, coord.y));
        result.red += cmul(comp.xy, euler);
        result.green += cmul(comp.zw, euler);
        comp = formatPickerLoadState(ivec2(coordSub, coord.y));
        result.blue += cmul(comp.xy, euler);
        result.alpha += cmul(comp.zw, euler);
        ++coordSub;
    }
    return result;
}

ComplexArray transformV(in ivec2 coord, in float pi, in float centerCoord) {
    float theta, coordF = pi * centerCoord * sizeDiv.y;
    int coordSub = coord.x + size.x;
    vec2 euler;
    vec4 comp;
    ComplexArray result = ComplexArray(vec2(0.0), vec2(0.0), vec2(0.0), vec2(0.0));
    for (int n = 0; n < size.y; ++n) {
        theta = float(n) * coordF;
        euler = getEuler(theta);
        comp = formatPickerLoadState(ivec2(coord.x, n));
        result.red += cmul(comp.xy, euler);
        result.green += cmul(comp.zw, euler);
        comp = formatPickerLoadState(ivec2(coordSub, n));
        result.blue += cmul(comp.xy, euler);
        result.alpha += cmul(comp.zw, euler);
    }
    return result;
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(coord, size))) return;
    bool isInverse = (state & 1) == 1;
    bool isVertical = (state & 2) == 2;
    bool isGenFromRGBA = (state & 4) == 4;
    bool isGenRGBA = (state & 8) == 8;
    vec2 centerCoord = isVertical ? vec2(coord.y, size.y) : vec2(coord.x, size.x);
    if (!isInverse) centerCoord.x -= centerCoord.y * 0.5;

    float pi = isInverse ? -PI2 : PI2;
    ComplexArray result = ComplexArray(vec2(0.0), vec2(0.0), vec2(0.0), vec2(0.0));
    if (isGenFromRGBA) {
        result = transformHFromRGBA(coord, centerCoord.x);
    } else {
        result = isVertical ? transformV(coord, pi, centerCoord.x) : transformH(coord, pi, centerCoord.x);
    }
    if (isInverse) {
        vec2 div = vec2(isVertical ? sizeDiv.y : sizeDiv.x);
        result.red *= div;
        result.green *= div;
        result.blue *= div;
        result.alpha *= div;
    }
    formatPickerStoreState(coord, result, isGenRGBA);
}